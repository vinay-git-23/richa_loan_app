// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ============================================
// CUSTOMERS TABLE
// ============================================
model Customer {
  id        Int      @id @default(autoincrement())
  name      String   @db.VarChar(100)
  mobile    String   @unique @db.VarChar(15)
  address   String?  @db.Text
  aadhaar   String?  @db.VarChar(12)
  photoUrl  String?  @db.LongText
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tokens       Token[]
  tokenBatches TokenBatch[]
  assignments  CustomerCollectorAssignment[]

  @@index([mobile])
  @@index([isActive])
  @@map("customers")
}

// ============================================
// COLLECTORS TABLE
// ============================================
model Collector {
  id            Int       @id @default(autoincrement())
  name          String    @db.VarChar(100)
  mobile        String    @unique @db.VarChar(15)
  email         String?   @unique @db.VarChar(100)
  passwordHash  String    @db.VarChar(255)
  plainPassword String?   @db.VarChar(50) // Store plain password for collector to view
  collectorId   String    @unique @db.VarChar(20)
  isActive      Boolean   @default(true)
  lastLogin     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  tokens       Token[]
  tokenBatches TokenBatch[]
  payments     Payment[]
  assignments  CustomerCollectorAssignment[]
  cashDeposits CashDeposit[]
  account      CollectorAccount?

  @@index([mobile])
  @@index([isActive])
  @@index([collectorId])
  @@map("collectors")
}

// ============================================
// TOKEN BATCH TABLE (for clubbed/grouped tokens)
// ============================================
model TokenBatch {
  id               Int         @id @default(autoincrement())
  batchNo          String      @unique @db.VarChar(50) // BATCH-20260106-0001
  customerId       Int
  collectorId      Int
  quantity         Int         // Number of tokens in this batch
  loanAmount       Decimal     @db.Decimal(10, 2) // Per token amount
  totalBatchAmount Decimal     @db.Decimal(10, 2) // Total across all tokens in batch
  interestType     InterestType
  interestValue    Decimal     @db.Decimal(10, 2)
  durationDays     Int
  dailyInstallment Decimal     @db.Decimal(10, 2) // Per token daily
  totalDailyAmount Decimal     @db.Decimal(10, 2) // Combined daily for batch
  startDate        DateTime    @db.Date
  endDate          DateTime    @db.Date
  status           TokenStatus @default(active)
  createdBy        UserType    @default(admin)
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  customer          Customer              @relation(fields: [customerId], references: [id])
  collector         Collector             @relation(fields: [collectorId], references: [id])
  tokens            Token[]               // Individual tokens in this batch
  batchSchedules    BatchRepaymentSchedule[]
  batchPayments     BatchPayment[]

  @@index([batchNo])
  @@index([customerId])
  @@index([collectorId])
  @@index([status])
  @@map("token_batches")
}

// ============================================
// BATCH REPAYMENT SCHEDULE TABLE
// ============================================
model BatchRepaymentSchedule {
  id                Int            @id @default(autoincrement())
  batchId           Int
  scheduleDate      DateTime       @db.Date
  installmentAmount Decimal        @db.Decimal(10, 2) // Combined daily amount for batch
  penaltyPerToken   Decimal        @default(0) @db.Decimal(10, 2) // Penalty per token
  totalPenalty      Decimal        @default(0) @db.Decimal(10, 2) // Total penalty (penaltyPerToken * quantity)
  totalDue          Decimal        @db.Decimal(10, 2) // installmentAmount + totalPenalty
  paidAmount        Decimal        @default(0) @db.Decimal(10, 2)
  penaltyWaived     Decimal        @default(0) @db.Decimal(10, 2) // Waived penalty amount
  paymentDate       DateTime?      @db.Date
  status            ScheduleStatus @default(pending)
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  batch    TokenBatch      @relation(fields: [batchId], references: [id], onDelete: Cascade)
  payments BatchPayment[]

  @@index([batchId])
  @@index([scheduleDate])
  @@index([status])
  @@index([batchId, scheduleDate])
  @@map("batch_repayment_schedule")
}

// ============================================
// BATCH PAYMENTS TABLE
// ============================================
model BatchPayment {
  id              Int         @id @default(autoincrement())
  batchId         Int
  scheduleId      Int
  collectorId     Int
  amount          Decimal     @db.Decimal(10, 2)
  penaltyWaived   Decimal     @default(0) @db.Decimal(10, 2) // Amount of penalty waived
  paymentMode     PaymentMode @default(cash)
  paymentDate     DateTime    @db.Date
  remarks         String?     @db.Text
  photoUrl        String?     @db.LongText
  isSynced        Boolean     @default(false)
  createdBy       UserType    @default(admin)
  createdAt       DateTime    @default(now())

  batch    TokenBatch               @relation(fields: [batchId], references: [id])
  schedule BatchRepaymentSchedule   @relation(fields: [scheduleId], references: [id])

  @@index([batchId])
  @@index([scheduleId])
  @@index([paymentDate])
  @@index([collectorId])
  @@index([isSynced])
  @@map("batch_payments")
}

// ============================================
// TOKENS/LOANS TABLE
// ============================================
model Token {
  id               Int         @id @default(autoincrement())
  tokenNo          String      @unique @db.VarChar(50)
  batchId          Int?        // Links to batch if part of a batch
  customerId       Int
  collectorId      Int
  loanAmount       Decimal     @db.Decimal(10, 2)
  interestType     InterestType
  interestValue    Decimal     @db.Decimal(10, 2)
  totalAmount      Decimal     @db.Decimal(10, 2)
  durationDays     Int
  dailyInstallment Decimal     @db.Decimal(10, 2)
  startDate        DateTime    @db.Date
  endDate          DateTime    @db.Date
  status           TokenStatus @default(active)
  createdBy        UserType    @default(admin)
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  batch              TokenBatch?         @relation(fields: [batchId], references: [id])
  customer           Customer            @relation(fields: [customerId], references: [id])
  collector          Collector           @relation(fields: [collectorId], references: [id])
  schedules          RepaymentSchedule[]
  payments           Payment[]
  paymentAllocations PaymentAllocation[]

  @@index([tokenNo])
  @@index([batchId])
  @@index([customerId])
  @@index([collectorId])
  @@index([status])
  @@index([startDate, endDate])
  @@map("tokens")
}

enum InterestType {
  fixed
  percentage
}

enum TokenStatus {
  active
  closed
  overdue
  cancelled
}

// ============================================
// REPAYMENT SCHEDULE TABLE
// ============================================
model RepaymentSchedule {
  id                Int            @id @default(autoincrement())
  tokenId           Int
  scheduleDate      DateTime       @db.Date
  installmentAmount Decimal        @db.Decimal(10, 2)
  penaltyAmount     Decimal        @default(0) @db.Decimal(10, 2)
  totalDue          Decimal        @db.Decimal(10, 2)
  paidAmount        Decimal        @default(0) @db.Decimal(10, 2)
  paymentDate       DateTime?      @db.Date
  status            ScheduleStatus @default(pending)
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  token              Token               @relation(fields: [tokenId], references: [id], onDelete: Cascade)
  payments           Payment[]
  paymentAllocations PaymentAllocation[]

  @@index([tokenId])
  @@index([scheduleDate])
  @@index([status])
  @@index([tokenId, scheduleDate])
  @@map("repayment_schedule")
}

enum ScheduleStatus {
  pending
  paid
  overdue
  partial
}

// ============================================
// PAYMENTS TABLE
// ============================================
model Payment {
  id            Int         @id @default(autoincrement())
  tokenId       Int?        // Made optional for multi-token payments
  scheduleId    Int?        // Made optional for multi-token payments
  collectorId   Int
  customerId    Int?        // Added to support customer-level payments
  amount        Decimal     @db.Decimal(10, 2)
  paymentMode   PaymentMode @default(cash)
  paymentDate   DateTime    @db.Date
  remarks       String?     @db.Text
  photoUrl      String?     @db.LongText
  isSynced      Boolean     @default(false)
  isMultiToken  Boolean     @default(false) // Flag for multi-token payments
  createdBy     UserType    @default(admin) // Track who created the payment
  createdAt     DateTime    @default(now())

  token       Token?              @relation(fields: [tokenId], references: [id])
  schedule    RepaymentSchedule?  @relation(fields: [scheduleId], references: [id])
  collector   Collector           @relation(fields: [collectorId], references: [id])
  allocations PaymentAllocation[] // Multi-token payment allocations

  @@index([tokenId])
  @@index([customerId])
  @@index([paymentDate])
  @@index([collectorId])
  @@index([isSynced])
  @@index([isMultiToken])
  @@map("payments")
}

// ============================================
// PAYMENT ALLOCATION TABLE (for multi-token payments)
// ============================================
model PaymentAllocation {
  id         Int      @id @default(autoincrement())
  paymentId  Int
  tokenId    Int
  scheduleId Int
  amount     Decimal  @db.Decimal(10, 2)
  createdAt  DateTime @default(now())

  payment  Payment           @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  token    Token             @relation(fields: [tokenId], references: [id])
  schedule RepaymentSchedule @relation(fields: [scheduleId], references: [id])

  @@index([paymentId])
  @@index([tokenId])
  @@index([scheduleId])
  @@map("payment_allocations")
}

enum PaymentMode {
  cash
  upi
  bank_transfer
}

// ============================================
// PENALTY CONFIGURATION TABLE
// ============================================
model PenaltyConfig {
  id              Int         @id @default(autoincrement())
  penaltyType     PenaltyType
  penaltyValue    Decimal     @db.Decimal(10, 2)
  graceDays       Int         @default(0)
  applyToLoanType String?     @db.VarChar(50)
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@index([isActive])
  @@map("penalty_config")
}

enum PenaltyType {
  fixed
  percent
}

// ============================================
// ADMIN USERS TABLE
// ============================================
model AdminUser {
  id           Int       @id @default(autoincrement())
  username     String    @unique @db.VarChar(50)
  email        String    @unique @db.VarChar(100)
  passwordHash String    @db.VarChar(255)
  role         AdminRole @default(admin)
  isActive     Boolean   @default(true)
  lastLogin    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  verifiedDeposits CashDeposit[] @relation("VerifiedBy")
  systemLogs       SystemLog[]
  account          AdminAccount?

  @@index([username])
  @@index([role])
  @@index([isActive])
  @@map("admin_users")
}

enum AdminRole {
  super_admin
  admin
  director
}

// ============================================
// CUSTOMER-COLLECTOR ASSIGNMENT TABLE
// ============================================
model CustomerCollectorAssignment {
  id           Int       @id @default(autoincrement())
  customerId   Int
  collectorId  Int
  assignedDate DateTime  @db.Date
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())

  customer  Customer  @relation(fields: [customerId], references: [id])
  collector Collector @relation(fields: [collectorId], references: [id])

  @@unique([customerId, collectorId])
  @@index([customerId])
  @@index([collectorId])
  @@index([isActive])
  @@map("customer_collector_assignment")
}

// ============================================
// CASH DEPOSITS TABLE
// ============================================
model CashDeposit {
  id               Int            @id @default(autoincrement())
  collectorId      Int
  amount           Decimal        @db.Decimal(10, 2)
  depositDate      DateTime       @db.Date
  receiptUrl       String?        @db.VarChar(255)
  verifiedBy       Int?
  verificationDate DateTime?
  status           DepositStatus  @default(pending)
  createdAt        DateTime       @default(now())

  collector Collector  @relation(fields: [collectorId], references: [id])
  verifier  AdminUser? @relation("VerifiedBy", fields: [verifiedBy], references: [id])

  @@index([collectorId])
  @@index([depositDate])
  @@index([status])
  @@map("cash_deposits")
}

enum DepositStatus {
  pending
  verified
  rejected
}

// ============================================
// SYSTEM LOGS TABLE
// ============================================
model SystemLog {
  id         Int       @id @default(autoincrement())
  userType   UserType
  userId     Int
  action     String    @db.VarChar(100)
  entityType String    @db.VarChar(50)
  entityId   Int?
  details    Json?
  ipAddress  String?   @db.VarChar(45)
  createdAt  DateTime  @default(now())

  adminUser AdminUser? @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([createdAt])
  @@index([action])
  @@map("system_logs")
}

enum UserType {
  admin
  collector
  director
}

// ============================================
// COLLECTOR ACCOUNT TABLE
// ============================================
model CollectorAccount {
  id            Int       @id @default(autoincrement())
  collectorId   Int       @unique
  currentBalance Decimal  @default(0) @db.Decimal(10, 2)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  collector     Collector @relation(fields: [collectorId], references: [id], onDelete: Cascade)
  transactions  CollectorAccountTransaction[]

  @@map("collector_accounts")
}

// ============================================
// COLLECTOR ACCOUNT TRANSACTION TABLE
// ============================================
model CollectorAccountTransaction {
  id            Int            @id @default(autoincrement())
  collectorAccountId Int
  transactionType String       @db.VarChar(20) // credit, debit
  amount        Decimal        @db.Decimal(10, 2)
  balanceAfter  Decimal        @db.Decimal(10, 2)
  referenceType String?        @db.VarChar(50) // payment, token_creation, admin_credit, etc.
  referenceId   Int?           // ID of related entity
  description   String?        @db.Text
  createdBy     Int?           // User ID
  createdByType UserType?      // admin or collector
  transactionDate DateTime     @default(now())
  createdAt     DateTime       @default(now())

  collectorAccount CollectorAccount @relation(fields: [collectorAccountId], references: [id], onDelete: Cascade)

  @@index([collectorAccountId])
  @@index([transactionDate])
  @@index([transactionType])
  @@index([referenceType, referenceId])
  @@map("collector_account_transactions")
}

// ============================================
// ADMIN ACCOUNT TABLE
// ============================================
model AdminAccount {
  id            Int       @id @default(autoincrement())
  adminId       Int       @unique
  currentBalance Decimal  @default(0) @db.Decimal(10, 2)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  admin         AdminUser @relation(fields: [adminId], references: [id], onDelete: Cascade)
  transactions  AdminAccountTransaction[]

  @@map("admin_accounts")
}

// ============================================
// ADMIN ACCOUNT TRANSACTION TABLE
// ============================================
model AdminAccountTransaction {
  id            Int            @id @default(autoincrement())
  adminAccountId Int
  transactionType String       @db.VarChar(20) // credit, debit
  amount        Decimal        @db.Decimal(10, 2)
  balanceAfter  Decimal        @db.Decimal(10, 2)
  referenceType String?        @db.VarChar(50) // payment, token_creation, manual_add, collector_credit, etc.
  referenceId   Int?           // ID of related entity
  description   String?        @db.Text
  createdBy     Int?           // User ID
  createdByType UserType?      // admin or collector
  transactionDate DateTime     @default(now())
  createdAt     DateTime       @default(now())

  adminAccount AdminAccount @relation(fields: [adminAccountId], references: [id], onDelete: Cascade)

  @@index([adminAccountId])
  @@index([transactionDate])
  @@index([transactionType])
  @@index([referenceType, referenceId])
  @@map("admin_account_transactions")
}
